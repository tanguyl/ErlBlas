23/02 - B. : 
    dot nif : 
        Résultat non déterministe. Avec les deux mêmes matrices, donne parfois le bon résultat, parfois pas : le dernier nombre est mauvais (overflow ?).
        J'essaie de debug le code c en utilisant les fonction de debug présentes.
        Je pense avoir trouvé : l'argument "beta" donné à dgemm était hardcodé à 1.0, probablement une typo. 
        Cela avait pour conséquence d'ajouter au produit la matrice C, initialisée par un malloc, donc garbage. 
        J'ai remplacé l'argument par la variable "beta", déjà initialisée à 0.0, et je n'ai visiblement plus de bug pour la multiplication.
    Segfault lorsque je lance le test "div_test" de numerl via rebar3.
25/02 - B. :
    inv_nif_test : donne un segfault.
        après deux heures d'investigation, il semble que ce soit un bug d'Openblas sur certaines versions d'Ubuntu lorsqu'on utilise une VM Java ou Erlang : 
        la fonction dgetfr produit un segfault si la dimension de la matrice est supérieur ou égale à 18.
    je continue la modification de la fonction mult.
26/02 - B :
    j'ai update le rebar.config pour prendre le code de notre fork de numerl, le temps qu'on push la correction sur le git de Tanguy,
        j'ai du changer le n° de commit manuellement dans le rebar.lock pour une raison obscure...
    mult fonctionne, "plus qu'à" faire les tests...; j'ai gardé l'ancienne fonction mult dans un fichier "backup"
    j'ai ajouté une fonction "display mat". pas très ergonomique mais ça évite les badargs...
    numerl : mtfl et mtfli modifiés pour renvoyer les matrice comme des listes de listes de nombres, et pas une longue liste de nombres, et push sur le fork de numerl
        j'ai repush pour corriger un horrible truc bizarre de C avec les pointeurs
    refactor un petit peu zeros

27/02 - L :
    j'ai rajouter une fonction toErl pour récuperer la representation matricielle d'une matrice block.
    2 petites sous fonctions ont été rajouter pour.
    Ce sera tres utile pour écrire des tests de validation.
    j'ai ecrit quelques tests pour la fonction matrix mais pas encore complet.

02/03 - B :
    travail préliminaire au benchmark : 
        remplacé la constant MAX_LENGTH par un terme du module "persistent_term", optimisé pour stocker des 
            termes jamais ou très peu écrit, avec lecture en temps constant (et court).
        j'ai modifié les fonctions de génération pour prendre en compte la modification, et enlevé les guards de la fonction matrix puisqu'on ne peut
            pas faire d'appel à get(max_length) à l'intérieur.
        pour le moment, la fonction "benchmark", lancéé au chargement du module block_mat, lie juste le term "max_length" à la valeur 5.
    bon, gros gros problèmes pour le benchmark : tape 250*250 en moins d'1ms 50 fois d'affilée, puis prend plus d'1ms pour faire une 50*50...
    okay, j'arrive à une solution satisfaisante malgré l'instabilité de ma VM : le benchmark est divisé en deux rounds : 
        Durant le premier, il multiplie la taille de la matrice par deux jusqu'à prendre plus d'1ms, et renvoie la valeur max qui a pris moins d'1ms.
        Durant le second, même chose mais mutliplie par 1.2 à chaque fois, et en commençant avec la valeur du premier round.
        Le premier round est répété 5 fois, et la valeur passée en argument au deuxième round est le minimum de ces 5 itérations.
        Le second round est répété 20 fois, et la valeur choisie comme valeur finale pour le paramètre max_length est la 2eme plus petite valeur,
            pour éviter les (rares - 1/80 en moyenne pour ma tres instable VM) outliers à valeur basse.

03/03 - B :
    réalisé une fonction matrix_conc qui fait la même chose que matrix, mais de manière concurrente. Spawn un nouveau processus à chaque appel récursif à matrix, 
        ainsi qu'à chaque appel à append ou recompose. L'overhead sur les perfomances est évidemment énorme si on garde des matrices 5x5, parce qu'elles se font en 
        1µs sur ma machine, donc le fait de spawner un processus, d'envoyer un message pour le résultat etc. à chaque fois rend la chose beaucoup plus lente. Pour les
        50x50 (1ms sur ma machine), on reste sur un overhead conséquent (2 à 3 fois plus long pour max length à 100 et 1000x1000). Cependant, la version 
        non concurrente de matrix utilise aussi tous les coeurs (la magie d'erlang ?) donc pas d'économies substentielles...
    corrigé un autre bug dans dgemm, qui ne s'exécutait pas quand B n'était pas carrée... c'était long >:(
    j'ai fait pareil pour zeros que pour matrix, et même problème... et la version de base utilise aussi tous les coeurs.

05/03 - L : 
    Inversion matricielle faite. J'ai rajouter une fonction scal qui fait la multiplication d'une matrice par un scalaire.
    Faudra peut etre la fusionner avec une fonction de multiplication plus générale.
    C'était nécessaire pour multiplier par -1. L'inversion fonctionne jusqu'à MAX_LENGTH = 18 ou ca segfault dans numerl.
    Aussi un probleme est que vu qu'on fait des inversions sur des sous-matrices il se peut que une sous-matrice soit singuliere et donc pas inverible alors que la matrice générale est inversible.
    C'est clairement un probleme de l'algorithme d'inversion et pas du code en lui même donc faudra peut etre trouver un autre algo...

10/03 - B :
    interface de dgemm exposée, fonctionne pour quelques tests simples avec chaque fois un paramètre qui change % à la multiplication.